import requests
from bs4 import BeautifulSoup
import argparse
import re
import json
import ssl
import socket
import time

requests.packages.urllib3.disable_warnings()

def get(url, timeout=5, allow_redirects=True):
    try:
        return requests.get(url, timeout=timeout, verify=False, allow_redirects=allow_redirects)
    except:
        return None

def post(url, data, headers=None, timeout=5):
    try:
        return requests.post(url, data=data, headers=headers, timeout=timeout, verify=False)
    except:
        return None

def print_status(msg, level="INFO"):
    colors = {
        "INFO": "[*]",
        "OK": "[+]",
        "WARN": "[!]",
        "FAIL": "[-]",
    }
    print(f"{colors.get(level, '[*]')} {msg}")

def check_version_meta(url):
    r = get(url)
    if r:
        match = re.search(r'content="WordPress (\d+\.\d+[^"]*)"', r.text)
        if match:
            print_status(f"Version found via meta: {match.group(1)}", "OK")
            return match.group(1)
        else:
            print_status("No version found in meta tag", "FAIL")
    return None

def check_version_readme(url):
    r = get(f"{url}/readme.html")
    if r and r.status_code == 200:
        match = re.search(r'Version (\d+\.\d+[^<]*)', r.text)
        if match:
            print_status(f"Version found via readme: {match.group(1)}", "OK")
            return match.group(1)
        else:
            print_status("Readme exists but no version found", "FAIL")
    else:
        print_status("readme.html not accessible", "FAIL")
    return None

def check_users_rest(url):
    r = get(f"{url}/wp-json/wp/v2/users")
    if r and r.status_code == 200:
        try:
            found = False
            for user in r.json():
                found = True
                print_status(f"User Found: {user.get('name')} ({user.get('slug')})", "OK")
            if not found:
                print_status("REST API accessible but no users found", "FAIL")
        except:
            print_status("REST API user enumeration failed", "FAIL")
    else:
        print_status("REST API not accessible", "FAIL")

def check_plugins_readme(url):
    plugins = ["elementor", "contact-form-7", "woocommerce", "revslider", "wp-file-manager"]
    found_plugins = {}
    for plugin in plugins:
        r = get(f"{url}/wp-content/plugins/{plugin}/readme.txt")
        if r and "== Changelog ==" in r.text:
            match = re.search(r'Stable tag:\s*([\d\.a-zA-Z\-]+)', r.text)
            if match:
                print_status(f"Plugin {plugin} version: {match.group(1)}", "OK")
                found_plugins[plugin] = match.group(1)
            else:
                print_status(f"Plugin {plugin} readme found, no version tag", "FAIL")
        else:
            print_status(f"Plugin {plugin} readme.txt not found", "FAIL")
    return found_plugins

def check_sensitive_files(url):
    files = [".env", ".git/HEAD", "wp-config.php.bak", ".htaccess", "phpinfo.php"]
    for f in files:
        r = get(f"{url}/{f}")
        if r and r.status_code == 200 and len(r.text) > 5:
            print_status(f"Sensitive file exposed: {f}", "WARN")
        else:
            print_status(f"{f} not accessible or not exposed", "FAIL")

def check_debug_log(url):
    r = get(f"{url}/wp-content/debug.log")
    if r and "Fatal error" in r.text:
        print_status("debug.log exposed!", "WARN")
    else:
        print_status("debug.log not found or not exposed", "FAIL")

def check_upload_dir(url):
    r = get(f"{url}/wp-content/uploads/")
    if r and "Index of" in r.text:
        print_status("Uploads directory is browsable", "WARN")
    else:
        print_status("Uploads directory not browsable", "FAIL")

def check_backup_files(url):
    names = ["wp-config", "backup", "site", "db"]
    extensions = ["zip", "sql", "tar.gz", "bak"]
    for name in names:
        for ext in extensions:
            r = get(f"{url}/{name}.{ext}")
            if r and r.status_code == 200:
                print_status(f"Backup file found: {name}.{ext}", "WARN")
            else:
                print_status(f"{name}.{ext} not found", "FAIL")

def check_http_headers(url):
    r = get(url)
    if r:
        h = r.headers
        if "X-Frame-Options" not in h:
            print_status("Missing X-Frame-Options", "WARN")
        else:
            print_status("X-Frame-Options present", "OK")
        if "Content-Security-Policy" not in h:
            print_status("Missing CSP header", "WARN")
        else:
            print_status("Content-Security-Policy present", "OK")
        if "X-Content-Type-Options" not in h:
            print_status("Missing X-Content-Type-Options", "WARN")
        else:
            print_status("X-Content-Type-Options present", "OK")
    else:
        print_status("Unable to retrieve headers", "FAIL")

def check_directory_traversal(url):
    payloads = [
        "?file=../../../../etc/passwd",
        "download.php?file=../../../../wp-config.php"
    ]
    for p in payloads:
        r = get(f"{url}/{p}")
        if r and "root:x:" in r.text:
            print_status(f"Directory traversal possible at: {p}", "WARN")
        else:
            print_status(f"No traversal detected at {p}", "FAIL")

def check_command_injection(url):
    payloads = [";id", "|id", "&id"]
    paths = ["/search.php?q=", "/index.php?q="]
    for path in paths:
        for payload in payloads:
            r = get(f"{url}{path}{payload}")
            if r and "uid=" in r.text:
                print_status(f"Possible command injection: {path}{payload}", "WARN")
                return
    print_status("No command injection points found", "FAIL")

def check_admin_ajax_actions(url):
    actions = ["revslider_ajax_action", "elementor_ajax", "fm_ajax"]
    for action in actions:
        r = post(f"{url}/wp-admin/admin-ajax.php", data={"action": action})
        if r and r.status_code == 200 and len(r.text) > 10:
            print_status(f"Ajax action '{action}' responded (may be vulnerable)", "WARN")
        else:
            print_status(f"Ajax action '{action}' not responding", "FAIL")

# New: Authentication test with common weak creds
def check_weak_login(url):
    login_url = f"{url}/wp-login.php"
    test_users = ["admin", "administrator", "test"]
    test_passwords = ["admin", "password", "123456", "admin123", "password1"]

    for user in test_users:
        for pwd in test_passwords:
            data = {
                "log": user,
                "pwd": pwd,
                "wp-submit": "Log In",
                "redirect_to": f"{url}/wp-admin/",
                "testcookie": "1"
            }
            r = post(login_url, data=data)
            if r and ("dashboard" in r.text.lower() or "wp-admin" in r.text.lower()):
                print_status(f"Weak login success: {user}:{pwd}", "WARN")
                return
            else:
                print_status(f"Failed login attempt: {user}:{pwd}", "FAIL")
    print_status("No weak login creds found", "OK")

# New: Plugin/Theme Vulnerability DB (simplified local example)
CVE_DB = {
    "elementor": {
        "3.0.0": ["CVE-2021-25094 - Stored XSS"],
        "3.5.5": ["CVE-2021-25095 - Auth Bypass"]
    },
    "contact-form-7": {
        "5.1": ["CVE-2020-35489 - CSRF"],
        "5.3": ["CVE-2021-24284 - XSS"]
    },
    "revslider": {
        "6.0.0": ["CVE-2014-9733 - Arbitrary File Upload"]
    }
}

def check_cve_db(found_plugins):
    for plugin, version in found_plugins.items():
        if plugin in CVE_DB:
            vulns = []
            for v in CVE_DB[plugin]:
                if version.startswith(v):
                    vulns.extend(CVE_DB[plugin][v])
            if vulns:
                for vuln in vulns:
                    print_status(f"Known vuln in {plugin} {version}: {vuln}", "WARN")
            else:
                print_status(f"No known vulns in {plugin} {version}", "OK")
        else:
            print_status(f"No CVE data for plugin {plugin}", "FAIL")

# New: Payload fuzzing - simple example on search param
def fuzz_search_param(url):
    fuzz_payloads = ["'", "\"", "<script>alert(1)</script>", "../../../../etc/passwd", "`id`", "|id|"]
    base_path = "/?s="
    vulnerable = False
    for payload in fuzz_payloads:
        r = get(url + base_path + payload)
        if r and (payload in r.text or "syntax error" in r.text.lower() or "alert(1)" in r.text):
            print_status(f"Potential injection with payload: {payload}", "WARN")
            vulnerable = True
        else:
            print_status(f"No injection with payload: {payload}", "FAIL")
    if not vulnerable:
        print_status("No injection vulnerabilities detected with fuzzing", "OK")

# New: Rate limiting detection
def detect_rate_limiting(url):
    test_url = url + "/"
    delays = []
    for i in range(10):
        start = time.time()
        r = get(test_url)
        elapsed = time.time() - start
        delays.append(elapsed)
        if r is None:
            print_status("No response during rate limiting test", "FAIL")
            return
        time.sleep(0.5)
    avg_delay = sum(delays)/len(delays)
    if avg_delay > 1.5:
        print_status(f"Possible rate limiting detected (avg response {avg_delay:.2f}s)", "WARN")
    else:
        print_status(f"No rate limiting detected (avg response {avg_delay:.2f}s)", "OK")

# New: SSL/TLS security checks (simple cert expiry and TLS version)
def ssl_tls_check(hostname):
    try:
        ctx = ssl.create_default_context()
        with ctx.wrap_socket(socket.socket(), server_hostname=hostname) as s:
            s.settimeout(5)
            s.connect((hostname, 443))
            cert = s.getpeercert()
            not_after = ssl.cert_time_to_seconds(cert['notAfter'])
            not_before = ssl.cert_time_to_seconds(cert['notBefore'])
            now = time.time()
            if now > not_after:
                print_status("SSL certificate expired", "WARN")
            else:
                print_status("SSL certificate is valid", "OK")

            # TLS version check - note: limited by Python ssl module defaults
            proto = s.version()
            if proto and proto.startswith("TLS"):
                print_status(f"TLS protocol version: {proto}", "OK")
                if proto in ("TLSv1", "TLSv1.1"):
                    print_status("Weak TLS version detected", "WARN")
            else:
                print_status("Unable to detect TLS version", "FAIL")

    except Exception as e:
        print_status(f"SSL/TLS check failed: {e}", "FAIL")

# New: Post-exploitation hints
def post_exploitation_checks(url):
    # Test for file upload page presence
    file_upload_paths = ["/wp-admin/media-new.php", "/wp-admin/upload.php"]
    found = False
    for path in file_upload_paths:
        r = get(url + path)
        if r and r.status_code == 200 and "upload" in r.text.lower():
            print_status(f"File upload page accessible: {path}", "WARN")
            found = True
    if not found:
        print_status("No obvious file upload page detected", "FAIL")

    # Simple check for remote code execution possibility on admin ajax
    r = post(f"{url}/wp-admin/admin-ajax.php", data={"action": "eval"})
    if r and "PHP" in r.text:
        print_status("Potential remote code execution via admin-ajax.php", "WARN")
    else:
        print_status("No RCE detected via admin-ajax.php", "FAIL")

def main():
    parser = argparse.ArgumentParser(description="Enhanced WordPress vulnerability scanner")
    parser.add_argument("url", help="Target WordPress site URL (e.g. https://example.com)")
    args = parser.parse_args()

    url = args.url.rstrip("/")

    print_status(f"Starting scan on {url}")

    # Version checks
    version = check_version_meta(url) or check_version_readme(url)

    # User enumeration
    check_users_rest(url)

    # Plugin versions
    plugins = check_plugins_readme(url)

    # Check sensitive info exposures
    check_sensitive_files(url)
    check_debug_log(url)
    check_upload_dir(url)
    check_backup_files(url)
    check_http_headers(url)

    # Known vulns from plugin versions
    check_cve_db(plugins)

    # Directory traversal
    check_directory_traversal(url)

    # Command injection
    check_command_injection(url)

    # Ajax actions
    check_admin_ajax_actions(url)

    # Weak login creds
    check_weak_login(url)

    # Payload fuzzing
    fuzz_search_param(url)

    # Rate limiting
    detect_rate_limiting(url)

    # SSL/TLS
    hostname = url.replace("https://", "").replace("http://", "").split("/")[0]
    ssl_tls_check(hostname)

    # Post exploitation hints
    post_exploitation_checks(url)

    print_status("Scan complete.")

if __name__ == "__main__":
    main()
